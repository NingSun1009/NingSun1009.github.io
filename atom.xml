<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rain&#39;s Blog</title>
  
  <subtitle>Ning</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-08T06:37:01.441Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ning Sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>内存管理</title>
    <link href="http://yoursite.com/2017/05/26/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2017/05/26/内存管理/</id>
    <published>2017-05-26T04:12:57.000Z</published>
    <updated>2018-06-08T06:37:01.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><h3 id="内存管理的思考方式"><a href="#内存管理的思考方式" class="headerlink" title="内存管理的思考方式"></a>内存管理的思考方式</h3><a id="more"></a><ul><li>自己生成的对象，自己所持有</li><li>非自己生成的对象，自己也能持有</li><li>不再需要自己持有的对象时释放</li><li>非自己持有的对象无法释放</li></ul><h4 id="自己生成的对象，自己所持有"><a href="#自己生成的对象，自己所持有" class="headerlink" title="自己生成的对象，自己所持有"></a>自己生成的对象，自己所持有</h4><p><code>id obj = [[NSObject alloc] init];</code></p><p>使用NSObject类的alloc类方法就能自己生成并持有对象。指向生成并持有对象的指针被赋值给变量obj。使用new类方法也能生成并持有对象。</p><p>copy方法利用基于NSCopying方法约定，由各类实现的copyWithZone:方法生成并持有对象的副本。</p><p>另外，下列名称也意味着自己生成并持有对象。<br>1.allocMyObject<br>2.newThatObject<br>3.copyThis<br>4.mutableCopyYourObject</p><h4 id="非自己生成的对象，自己也能持有"><a href="#非自己生成的对象，自己也能持有" class="headerlink" title="非自己生成的对象，自己也能持有"></a>非自己生成的对象，自己也能持有</h4><p><code>id obj = [NSMutableArray array];</code></p><p>NSMutableArray类对象被赋值给变量obj，但变量obj自己并不持有该对象。使用retain方法可以持有该对象。</p><h4 id="不再需要自己持有的对象时释放"><a href="#不再需要自己持有的对象时释放" class="headerlink" title="不再需要自己持有的对象时释放"></a>不再需要自己持有的对象时释放</h4><p>自己持有的对象，一旦不需要，持有者有义务释放该对象。释放使用release方法。</p><p>[obj release];<br>指向对象的指针仍然被保留在变量obj中，貌似能够访问，但对象一经释放绝对不可访问。</p><p>用某个方法生成对象，并将其返还给该方法的调用方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (id)allocObject &#123;</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line">//取得非自己生成并持有的对象</span><br><span class="line">id obj1 = [obj0 allocObject];</span><br></pre></td></tr></table></figure><p>用某个方法取得的对象存在，但自己不持有对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (id)object &#123;</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">[obj autorelease];</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>autorelease方法提供这样的功能，使对象在超出指定的生存范围时能够自动并正确地释放（调用release方法）</p><p>使用NSMutableArray类的array类方法等可以取得谁都不持有的对象，这些方法都是通过autorelease而实现的。此外，根据命名规则，不能以alloc/new/copy/mutableCopy开头。</p></blockquote><h4 id="无法释放非自己持有的对象"><a href="#无法释放非自己持有的对象" class="headerlink" title="无法释放非自己持有的对象"></a>无法释放非自己持有的对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">[obj release];</span><br><span class="line">//释放后再次释放已非自己持有的对象！应用程序崩溃！</span><br><span class="line">//崩溃情况：</span><br><span class="line">//  再度废弃已经废弃了的对象时崩溃</span><br><span class="line">//  访问已经废弃的对象时崩溃</span><br><span class="line">[obj release];</span><br><span class="line"></span><br><span class="line">==========================================</span><br><span class="line"></span><br><span class="line">//取得的对象存在，但自己不持有对象</span><br><span class="line">id obj1 = [obj0 object];</span><br><span class="line">//释放了非自己持有的对象！应用程序崩溃！</span><br><span class="line">[obj1 release];</span><br></pre></td></tr></table></figure><h3 id="alloc-retain-release-dealloc实现"><a href="#alloc-retain-release-dealloc实现" class="headerlink" title="alloc/retain/release/dealloc实现"></a>alloc/retain/release/dealloc实现</h3><h4 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h4><p>NSZone是为防止内存碎片化而引入的结构。</p><p>GNUStep的alloc类方法用struct obj_layout中的retained整数来保存引用计数，并将其写入对象内存的头部，该对象内存块全部置0后返回。</p><p>苹果是通过散列表（引用计数表）来管理引用计数。</p><ul><li>通过内存块头部管理引用计数的好处：</li></ul><ul><li>少量代码即可完成</li><li>能够统一管理引用计数用内存块与对象用内存块</li></ul><ul><li>通过引用计数表管理引用计数的好处：</li></ul><ul><li>对象用内存块的分配无需考虑内存块头部。</li><li>引用计数表各记录中存有内存块地址，可从各个记录追溯到各对象的内存块。</li></ul><p>调用栈：<br>+alloc<br>+allocWithZone:<br>class_createInstance<br>calloc</p><p><strong>总结：</strong></p><ul><li>在Objective-C的对象中存有引用计数这一整数值</li><li>调用alloc或事retain方法后，引用计数值加1</li><li>调用release后，引用计数值减1</li><li>引用计数值为0时，调用dealloc方法废弃对象</li></ul><h3 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h3><p>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];<br>id obj = [[NSObject alloc] init];<br>[obj autorelease];<br>[pool drain];</p><blockquote><p>另外，Cocoa框架中也有很多类方法用于返回autorelease的对象。比如NSMutableArray类的arrayWithCapacity类方法。<br><code>id array = [NSMutableArray arrayWithCapacity:1];</code><br>此源代码等同于以下源代码<br><code>id array = [[[NSMutableArray alloc] initWithCapacity:1] autorelease];</code></p></blockquote><p><strong>实现</strong></p><p>class AutoreleasePoolPage {<br>static inline void *push() {<br>//相当于生成或持有NSAutoreleasePool类对象<br>}</p><p>staic inline void <em>pop(void </em>token) {<br>//相当于废弃NSAutoreleasePool类对象<br>releaseAll();<br>}</p><p>static inline id autorelease(id obj) {<br>//相当于NSAutoreleasePool类的addObject类方法<br>AutoreleasePoolPage *autoreleasePoolPage = 取得正在使用的AutoreleasePoolPage实例;<br>autoreleasePoolPage-&gt;add(obj);<br>}</p><p>id *add(id obj) {<br>//将对象追加到内部数组中；<br>}</p><p>void releaseAll() {<br>//调用内部数组中对象的release实例方法<br>}</p><p>void *objc_autoreleasePoolPush(void){<br>return AutoreleasePoolPage::push();<br>}</p><p>void objc_autoreleasePoolPop(void *ctxt) {<br>AutoreleasePoolPage::pop(ctxt);<br>}</p><p>id *objc_autorelease(id obj) {<br>return AutoreleasePoolPage::autorelease(obj);<br>}<br>}</p><blockquote><p>另外，可以通过NSAutoreleasePool类中的调试用非公开类方法showPools来确认已被autorelease的对象的状况。</p><p>autorelease NSAutoreleasePool对象会发生异常,因为它的autorelease实例方法已被该类重载，因此运行时就会出错。</p></blockquote><h3 id="ARC规则"><a href="#ARC规则" class="headerlink" title="ARC规则"></a>ARC规则</h3><h4 id="所以权修饰符"><a href="#所以权修饰符" class="headerlink" title="所以权修饰符"></a>所以权修饰符</h4><ul><li>__strong</li><li>__weak</li><li>__unsafe_unretained</li><li>__autoreleasing</li></ul><h5 id="strong修饰符"><a href="#strong修饰符" class="headerlink" title="__strong修饰符"></a>__strong修饰符</h5><p>是id类型和对象类型默认的所有权修饰符(强引用，持有对象实例)<br><code>id __strong obj = [[NSObject alloc] init];</code></p><p>通过__strong修饰符，不必再次键入retain或者release</p><h5 id="weak修饰符（iOS5）"><a href="#weak修饰符（iOS5）" class="headerlink" title="__weak修饰符（iOS5）"></a>__weak修饰符（iOS5）</h5><p>弱引用，不持有对象实例，解决循环引用<br>在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且处于nil被赋值的状态（空弱引用）</p><h5 id="unsafe-unretained修饰符"><a href="#unsafe-unretained修饰符" class="headerlink" title="__unsafe_unretained修饰符"></a>__unsafe_unretained修饰符</h5><p>该修饰符修饰的变量不属于编译器的内存管理对象<br>既不持有对象的强引用也不持有对象的弱引用</p><h5 id="autoreleasing修饰符"><a href="#autoreleasing修饰符" class="headerlink" title="__autoreleasing修饰符"></a>__autoreleasing修饰符</h5><p>arc中使用@autoreleasepool块来替代NSAutoreleasePool类对象生成、持有以及废弃。</p><p>通过将对象赋值给附加了__autoreleasing修饰符的变量来替代调用autorelease方法。</p><p>init 方法返回值的对象不注册到autoreleasepool。</p><p>对象作为函数的返回值，编译器会自动将其注册到autoreleasepool。</p><p>访问附有__weak修饰符的变量时必须访问注册到autoreleasepool的对象。这是因为__weak修饰符只持有对象的弱引用，而在访问引用对象的过程中，该对象有可能被废弃。如果把要访问的对象注册到autoreleasepool中，那么在@autoreleasepool块结束之前都能确保该对象存在。</p><p>id __weak obj1 = obj0;<br>NSLog(@”class=%@”,[obj1 class]);</p><p>等同于</p><p>id <strong>weak obj1 = obj0;<br>id </strong>autoreleasing tmp = obj1;<br>NSLog(@”class=%@”,[tmp class]);</p><p>LLVM3.0以上，ARC无效也可以使用@autoreleasepool块。</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>不能使用retain/release/retainCount/autorelease</li><li>不能使用NSAllocateObject/NSDeallocateObject</li><li>须遵守内存管理的方法命名规则</li><li>不要显示调用dealloc</li><li>使用@autoreleasepool块代替NSAutoreleasePool</li><li>不能使用区域(NSZone)</li><li>对象型变量不能作为C语言结构体(struct/union)的成员</li><li>显示转换id和void*</li></ul><blockquote><p>arc中init开始的方法必须是实例方法，并且必须返回对象。返回的对象必须为id类型或该方法声明类的对象类型，或是该类的超类型或子类型。该返回对象并不注册到autoreleasepool上。</p><p>要把对象型变量加入到结构体成员中，可强制转换为void*或是附加__unsafe_unretained修饰符。因为该修饰符修饰的变量不属于编译器的内存管理对象。</p><p><strong>__bridge转换，可以转换id和void*,但其安全型与赋值给</strong>unsafe_unretained修饰符相近，甚至会更低。</p><p><strong>__bridge_ratained转换和</strong>bridge_transfer转换<br>____bridge_ratained可使要转换赋值的变量也持有所赋值的对象</p><p>____birdge_transfer被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放</p></blockquote><h3 id="ARC实现"><a href="#ARC实现" class="headerlink" title="ARC实现"></a>ARC实现</h3><p>编译器+oc运行时库 进行内存管理</p><h4 id="strong"><a href="#strong" class="headerlink" title="__strong"></a>__strong</h4><p>通过objc_autoreleaseReturnValue和objc_retainAutoreleaseReturnValue实现了最优化，省略了autoreleasepool注册。</p><h4 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h4><ul><li>若附有__weak修饰符的变量所引用的对象被废弃，则将nil赋值给改变了</li><li>使用附有__weak修饰符的变量，即是使用注册到autoreleasepool中的对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//objc_storeWeak函数将第二参数的赋值对象的地址作为键值，将第一参数附有__weak修饰符的变量地址注册到weak表中，如果第二参数为0，则把变量的地址从weak表中删除。</span><br><span class="line">id obj1;</span><br><span class="line">obj1 = 0;</span><br><span class="line">objc_storeWeak(&amp;obj1,obj);</span><br><span class="line">objc_storeWeak(&amp;obj1,0);</span><br></pre></td></tr></table></figure><p>weak表同引用计数表一样都为散列表</p><p>1.从weak表中获取废弃对象的地址作为键值的记录<br>2.将包含在记录中的所有附有__weak修饰符变量的地址，赋值为nil<br>3.从weak表中删除该记录<br>4.从引用计数表中删除废弃对象的地址为键值的记录</p><blockquote><p>不支持__weak修饰的类，如NSMachPort类</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引用计数&quot;&gt;&lt;a href=&quot;#引用计数&quot; class=&quot;headerlink&quot; title=&quot;引用计数&quot;&gt;&lt;/a&gt;引用计数&lt;/h2&gt;&lt;h3 id=&quot;内存管理的思考方式&quot;&gt;&lt;a href=&quot;#内存管理的思考方式&quot; class=&quot;headerlink&quot; title=&quot;内存管理的思考方式&quot;&gt;&lt;/a&gt;内存管理的思考方式&lt;/h3&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="内存管理" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统知识</title>
    <link href="http://yoursite.com/2017/05/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2017/05/26/深入理解计算机系统/</id>
    <published>2017-05-26T04:12:57.000Z</published>
    <updated>2018-06-08T16:18:41.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><p><strong>信息</strong> = 位+上下文</p><h2 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h2><p><img src="img/buildSystem.png" alt="编译系统"></p><ul><li><p>预处理阶段</p><p>  读取头文件中的内容并插入程序文本中，得到另一个c程序，通常以.i为文件扩展名。</p></li><li><p>编译阶段</p><p>  编译器将源.i程序翻译成汇编语言程序，以.s作为文件扩展名。汇编语言为不同的高级语言的不同编译器提供了通用的输出语言。例如，C编译器和Fortran编译器产生的输出文件用的都是一样的汇编语言。</p></li><li><p>汇编阶段</p><p>  汇编器将.翻译成机器语言指令，并打包成可重定位目标程序，并保存在.o文件中。</p></li><li><p>链接阶段</p><p>  链接器负责将程序中用到的.o文件合并到当前的.o文件中，生成可执行目标文件，该文件可以被加载到内存中，由系统执行。</p></li></ul><h2 id="为何要了解编译系统的工作原理？"><a href="#为何要了解编译系统的工作原理？" class="headerlink" title="为何要了解编译系统的工作原理？"></a>为何要了解编译系统的工作原理？</h2><ul><li>优化程序性能</li><li>理解链接时出现的错误</li><li>避免安全漏洞</li></ul><h2 id="处理器读取并解释储存在内存中的指令"><a href="#处理器读取并解释储存在内存中的指令" class="headerlink" title="处理器读取并解释储存在内存中的指令"></a>处理器读取并解释储存在内存中的指令</h2><h3 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h3><p><img src="img/computerComposition.png" alt="计算机组成"></p><p>1.总线</p><p>贯穿整个系统的一组电子管道。它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字。每个系统的字的长度不同，有4、8等字节。</p><p>2.I/O设备</p><p>系统与外部世界的联系通道。如键盘、鼠标、显示器、磁盘驱动器（磁盘）。每个i/o设备通过控制器或适配器与i/o总线相连。控制器与适配器的区别在于它们的封装方式。控制器是i/o设备本身或者系统主板上的芯片组。而适配器则是一块插在主板插槽上的卡。</p><p>3.主存</p><p>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，是由一组动态随机存取存储器（DRAM）芯片组成。<br>从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。</p><p>4.处理器</p><p>中央处理单元（CPU）,简称处理器，是解释（或执行）存储在主存中指令的引擎。其核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻。PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。</p><p>寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。</p><p>算术/逻辑单元（ALU）计算新的数据和地址值。</p><p>CPU操作：</p><ul><li>加载：从主存复制一个字节或一个字到寄存器，以覆盖寄存器原来的内容。</li><li>存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。</li><li>操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。</li><li>跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖PC中原来的值。 </li></ul><p>处理器指令集架构和微体系结构：</p><pre><code>指令集架构描述的是每条机器代码指令的效果。微体系结构描述的是处理器实际上如何实现的。</code></pre><p>程序执行过程：</p><p>1.可执行目标文件中的代码和数据从磁盘复制到主存（利用直接存储器存取技术（DMA）），数据可以不通过处理器而直接从磁盘到达主存。</p><p>2.处理器执行指令，将数据字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示到屏幕上。</p><h2 id="高速缓存的重要性"><a href="#高速缓存的重要性" class="headerlink" title="高速缓存的重要性"></a>高速缓存的重要性</h2><p>1.复制操作话费大量时间</p><p>2.根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。</p><p>3.加快处理器的运行速度比加快主存的运行速度要容易和便宜的多。</p><p><strong>高速缓存存储器(cache memory)</strong></p><p>存放处理器近期可能会需要的信息</p><p>程序具有访问局部区域里的数据和代码的趋势。</p><p>L1和L2高速缓存：位于处理器芯片上，用一种叫做静态随机访问存储器(SRAM)的硬件技术实现的。</p><h2 id="存储设备形成层次结构"><a href="#存储设备形成层次结构" class="headerlink" title="存储设备形成层次结构"></a>存储设备形成层次结构</h2><p><img src="img/storageHierarchy.png" alt="存储设备层级结构"></p><h2 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h2><p>计算机系统的分层视图</p><p><img src="img/systemHierarchy.png" alt="计算机系统的分层视图"></p><p>操作系统的两个基本功能：</p><p>1.防止硬件被失控的应用程序滥用。</p><p>2.向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。</p><blockquote><p>操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。</p></blockquote><p><img src="img/systemAbstract.png" alt="操作系统提供的抽象表示"></p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><strong>进程</strong>是操作系统对一个正在运行的程序的一种抽象。</p><p>在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。</p><p><strong>并发运行</strong>，则是说一个进程的指令和另一个进行的指令是交错执行的。</p><p>操作系统实现这种交错执行的机制称为<strong>上下文切换</strong>。</p><p>操作系统保持跟踪进程运行所需的所有状态信息，这种状态，称为<strong>上下文</strong>。</p><p>从一个进程到另一个进程的转换是由操作系统的<strong>内核</strong>(kernel)管理的，<strong>内核</strong>是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，它就执行一条特殊的<strong>系统调用</strong>指令，将控制权交给内核。</p><blockquote><p>内核不是一个独立的进程，它是系统管理全部进程所用代码和数据结构的集合。</p></blockquote><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程可有多个称为<strong>线程</strong>的执行单元组成。</p><p>每个<strong>线程</strong>都运行在进程的上下文中，并共享同样的代码和全局数据。</p><p>多线程之间比多进程之间更容易共享数据，而且线程一般来说比进程更高效。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><strong>虚拟内存</strong>是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。</p><p>基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。</p><p><strong>进程的虚拟地址空间:</strong></p><p><img src="img/进程的虚拟地址空间.png" alt="进程的虚拟地址空间"></p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p><strong>文件</strong>就是字节序列。每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。系统中所有输入输出都是通过使用一小组称为Unix I/O的系统函数调用读写文件来实现的。</p><h2 id="系统之间利用网络通信"><a href="#系统之间利用网络通信" class="headerlink" title="系统之间利用网络通信"></a>系统之间利用网络通信</h2><p>从一个单独的系统来看，网络可视为一个I/O设备，当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，而不是比如说到达本地磁盘驱动器。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。</p><h2 id="重要主题"><a href="#重要主题" class="headerlink" title="重要主题"></a>重要主题</h2><h3 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h3><p>要想显著加速整个系统，必须提升全系统中相当大的部分的速度。</p><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p><strong>并发（concurrency）</strong></p><p>指一个同时具有多个活动的系统。</p><p><strong>并行（parallelism）</strong></p><p>指用并发来使一个系统运行得更快。</p><p>1.线程级并发</p><p>构建在进程这个抽象之上。</p><p>处理器：</p><ul><li>单处理器</li><li>多处理器（多核&amp;超线程）</li></ul><p><strong>多核</strong></p><p>多核处理器是将多个CPU（称为“核”）集成到一个集成电路芯片上。</p><p><img src="img/多核处理器的组织结构.png" alt="多核处理器的组织结构"></p><p><strong>超线程</strong></p><p>有时称为同时多线程，是一项允许一个CPU执行多个控制流的技术。它涉及CPU某些硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份。常规的处理器需要大约20000个时钟周期做不同线程间的切换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。</p><p>2.指令级并行</p><p>在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为<strong>指令级并行</strong>。</p><p>一个时钟处理一条或多条指令。如果某处理器可以达到比一个周期一条指令更快的执行速率，就称之为<strong>超标量处理器</strong>。</p><p>3.单指令、多数据并行</p><p>在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMD并行。</p><h3 id="计算机系统中抽象的重要性"><a href="#计算机系统中抽象的重要性" class="headerlink" title="计算机系统中抽象的重要性"></a>计算机系统中抽象的重要性</h3><p><img src="img/计算机系统的一系列抽象.png" alt="计算机系统的一系列抽象"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，它们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是ASCII文本，然后被编译器和链接器翻译成二进制可执行文件。</p><p>处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O设备和CPU寄存器之间复制数据，所以将系统中的存储设备划分成层次结构。</p><p>操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象：1）文件是对I/O设备的抽象；2）虚拟内存是对主存和磁盘的抽象；3）进程是处理器、主存和I/O设备的抽象。</p><p>最后，网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种I/O设备。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;信息&quot;&gt;&lt;a href=&quot;#信息&quot; class=&quot;headerlink&quot; title=&quot;信息&quot;&gt;&lt;/a&gt;信息&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;信息&lt;/strong&gt; = 位+上下文&lt;/p&gt;
&lt;h2 id=&quot;编译系统&quot;&gt;&lt;a href=&quot;#编译系统&quot; class=&quot;h
      
    
    </summary>
    
      <category term="计算机系统" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机系统" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
