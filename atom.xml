<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rain&#39;s Blog</title>
  
  <subtitle>subtitle</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-06T09:27:24.914Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ning Sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/06/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/06/06/内存管理/</id>
    <published>2018-06-06T09:01:07.307Z</published>
    <updated>2018-06-06T09:27:24.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><h3 id="内存管理的思考方式"><a href="#内存管理的思考方式" class="headerlink" title="内存管理的思考方式"></a>内存管理的思考方式</h3><ul><li>自己生成的对象，自己所持有</li><li>非自己生成的对象，自己也能持有</li><li>不再需要自己持有的对象时释放</li><li>非自己持有的对象无法释放</li></ul><h4 id="自己生成的对象，自己所持有"><a href="#自己生成的对象，自己所持有" class="headerlink" title="自己生成的对象，自己所持有"></a>自己生成的对象，自己所持有</h4><p><code>id obj = [[NSObject alloc] init];</code></p><p>使用NSObject类的alloc类方法就能自己生成并持有对象。指向生成并持有对象的指针被赋值给变量obj。使用new类方法也能生成并持有对象。</p><p>copy方法利用基于NSCopying方法约定，由各类实现的copyWithZone:方法生成并持有对象的副本。</p><p>另外，下列名称也意味着自己生成并持有对象。<br>1.allocMyObject<br>2.newThatObject<br>3.copyThis<br>4.mutableCopyYourObject</p><h4 id="非自己生成的对象，自己也能持有"><a href="#非自己生成的对象，自己也能持有" class="headerlink" title="非自己生成的对象，自己也能持有"></a>非自己生成的对象，自己也能持有</h4><p><code>id obj = [NSMutableArray array];</code></p><p>NSMutableArray类对象被赋值给变量obj，但变量obj自己并不持有该对象。使用retain方法可以持有该对象。</p><h4 id="不再需要自己持有的对象时释放"><a href="#不再需要自己持有的对象时释放" class="headerlink" title="不再需要自己持有的对象时释放"></a>不再需要自己持有的对象时释放</h4><p>自己持有的对象，一旦不需要，持有者有义务释放该对象。释放使用release方法。</p><p>[obj release];<br>指向对象的指针仍然被保留在变量obj中，貌似能够访问，但对象一经释放绝对不可访问。</p><p>用某个方法生成对象，并将其返还给该方法的调用方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (id)allocObject &#123;</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line">//取得非自己生成并持有的对象</span><br><span class="line">id obj1 = [obj0 allocObject];</span><br></pre></td></tr></table></figure><p>用某个方法取得的对象存在，但自己不持有对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (id)object &#123;</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">[obj autorelease];</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>autorelease方法提供这样的功能，使对象在超出指定的生存范围时能够自动并正确地释放（调用release方法）</p><p>使用NSMutableArray类的array类方法等可以取得谁都不持有的对象，这些方法都是通过autorelease而实现的。此外，根据命名规则，不能以alloc/new/copy/mutableCopy开头。</p></blockquote><h4 id="无法释放非自己持有的对象"><a href="#无法释放非自己持有的对象" class="headerlink" title="无法释放非自己持有的对象"></a>无法释放非自己持有的对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">[obj release];</span><br><span class="line">//释放后再次释放已非自己持有的对象！应用程序崩溃！</span><br><span class="line">//崩溃情况：</span><br><span class="line">//  再度废弃已经废弃了的对象时崩溃</span><br><span class="line">//  访问已经废弃的对象时崩溃</span><br><span class="line">[obj release];</span><br><span class="line"></span><br><span class="line">==========================================</span><br><span class="line"></span><br><span class="line">//取得的对象存在，但自己不持有对象</span><br><span class="line">id obj1 = [obj0 object];</span><br><span class="line">//释放了非自己持有的对象！应用程序崩溃！</span><br><span class="line">[obj1 release];</span><br></pre></td></tr></table></figure><h3 id="alloc-retain-release-dealloc实现"><a href="#alloc-retain-release-dealloc实现" class="headerlink" title="alloc/retain/release/dealloc实现"></a>alloc/retain/release/dealloc实现</h3><h4 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h4><p>NSZone是为防止内存碎片化而引入的结构。</p><p>GNUStep的alloc类方法用struct obj_layout中的retained整数来保存引用计数，并将其写入对象内存的头部，该对象内存块全部置0后返回。</p><p>苹果是通过散列表（引用计数表）来管理引用计数。</p><ul><li>通过内存块头部管理引用计数的好处：</li></ul><ul><li>少量代码即可完成</li><li>能够统一管理引用计数用内存块与对象用内存块</li></ul><ul><li>通过引用计数表管理引用计数的好处：</li></ul><ul><li>对象用内存块的分配无需考虑内存块头部。</li><li>引用计数表各记录中存有内存块地址，可从各个记录追溯到各对象的内存块。</li></ul><p>调用栈：<br>+alloc<br>+allocWithZone:<br>class_createInstance<br>calloc</p><p><strong>总结：</strong></p><ul><li>在Objective-C的对象中存有引用计数这一整数值</li><li>调用alloc或事retain方法后，引用计数值加1</li><li>调用release后，引用计数值减1</li><li>引用计数值为0时，调用dealloc方法废弃对象</li></ul><h3 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h3><p>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];<br>id obj = [[NSObject alloc] init];<br>[obj autorelease];<br>[pool drain];</p><blockquote><p>另外，Cocoa框架中也有很多类方法用于返回autorelease的对象。比如NSMutableArray类的arrayWithCapacity类方法。<br><code>id array = [NSMutableArray arrayWithCapacity:1];</code><br>此源代码等同于以下源代码<br><code>id array = [[[NSMutableArray alloc] initWithCapacity:1] autorelease];</code></p></blockquote><p><strong>实现</strong></p><p>class AutoreleasePoolPage {<br>static inline void *push() {<br>//相当于生成或持有NSAutoreleasePool类对象<br>}</p><p>staic inline void <em>pop(void </em>token) {<br>//相当于废弃NSAutoreleasePool类对象<br>releaseAll();<br>}</p><p>static inline id autorelease(id obj) {<br>//相当于NSAutoreleasePool类的addObject类方法<br>AutoreleasePoolPage *autoreleasePoolPage = 取得正在使用的AutoreleasePoolPage实例;<br>autoreleasePoolPage-&gt;add(obj);<br>}</p><p>id *add(id obj) {<br>//将对象追加到内部数组中；<br>}</p><p>void releaseAll() {<br>//调用内部数组中对象的release实例方法<br>}</p><p>void *objc_autoreleasePoolPush(void){<br>return AutoreleasePoolPage::push();<br>}</p><p>void objc_autoreleasePoolPop(void *ctxt) {<br>AutoreleasePoolPage::pop(ctxt);<br>}</p><p>id *objc_autorelease(id obj) {<br>return AutoreleasePoolPage::autorelease(obj);<br>}<br>}</p><blockquote><p>另外，可以通过NSAutoreleasePool类中的调试用非公开类方法showPools来确认已被autorelease的对象的状况。</p><p>autorelease NSAutoreleasePool对象会发生异常,因为它的autorelease实例方法已被该类重载，因此运行时就会出错。</p></blockquote><h3 id="ARC规则"><a href="#ARC规则" class="headerlink" title="ARC规则"></a>ARC规则</h3><h4 id="所以权修饰符"><a href="#所以权修饰符" class="headerlink" title="所以权修饰符"></a>所以权修饰符</h4><ul><li>__strong</li><li>__weak</li><li>__unsafe_unretained</li><li>__autoreleasing</li></ul><h5 id="strong修饰符"><a href="#strong修饰符" class="headerlink" title="__strong修饰符"></a>__strong修饰符</h5><p>是id类型和对象类型默认的所有权修饰符(强引用，持有对象实例)<br><code>id __strong obj = [[NSObject alloc] init];</code></p><p>通过__strong修饰符，不必再次键入retain或者release</p><h5 id="weak修饰符（iOS5）"><a href="#weak修饰符（iOS5）" class="headerlink" title="__weak修饰符（iOS5）"></a>__weak修饰符（iOS5）</h5><p>弱引用，不持有对象实例，解决循环引用<br>在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且处于nil被赋值的状态（空弱引用）</p><h5 id="unsafe-unretained修饰符"><a href="#unsafe-unretained修饰符" class="headerlink" title="__unsafe_unretained修饰符"></a>__unsafe_unretained修饰符</h5><p>该修饰符修饰的变量不属于编译器的内存管理对象<br>既不持有对象的强引用也不持有对象的弱引用</p><h5 id="autoreleasing修饰符"><a href="#autoreleasing修饰符" class="headerlink" title="__autoreleasing修饰符"></a>__autoreleasing修饰符</h5><p>arc中使用@autoreleasepool块来替代NSAutoreleasePool类对象生成、持有以及废弃。</p><p>通过将对象赋值给附加了__autoreleasing修饰符的变量来替代调用autorelease方法。</p><p>init 方法返回值的对象不注册到autoreleasepool。</p><p>对象作为函数的返回值，编译器会自动将其注册到autoreleasepool。</p><p>访问附有__weak修饰符的变量时必须访问注册到autoreleasepool的对象。这是因为__weak修饰符只持有对象的弱引用，而在访问引用对象的过程中，该对象有可能被废弃。如果把要访问的对象注册到autoreleasepool中，那么在@autoreleasepool块结束之前都能确保该对象存在。</p><p>id __weak obj1 = obj0;<br>NSLog(@”class=%@”,[obj1 class]);</p><p>等同于</p><p>id <strong>weak obj1 = obj0;<br>id </strong>autoreleasing tmp = obj1;<br>NSLog(@”class=%@”,[tmp class]);</p><p>LLVM3.0以上，ARC无效也可以使用@autoreleasepool块。</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>不能使用retain/release/retainCount/autorelease</li><li>不能使用NSAllocateObject/NSDeallocateObject</li><li>须遵守内存管理的方法命名规则</li><li>不要显示调用dealloc</li><li>使用@autoreleasepool块代替NSAutoreleasePool</li><li>不能使用区域(NSZone)</li><li>对象型变量不能作为C语言结构体(struct/union)的成员</li><li>显示转换id和void*</li></ul><blockquote><p>arc中init开始的方法必须是实例方法，并且必须返回对象。返回的对象必须为id类型或该方法声明类的对象类型，或是该类的超类型或子类型。该返回对象并不注册到autoreleasepool上。</p><p>要把对象型变量加入到结构体成员中，可强制转换为void*或是附加__unsafe_unretained修饰符。因为该修饰符修饰的变量不属于编译器的内存管理对象。</p><p><strong>__bridge转换，可以转换id和void*,但其安全型与赋值给</strong>unsafe_unretained修饰符相近，甚至会更低。</p><p><strong>__bridge_ratained转换和</strong>bridge_transfer转换<br>____bridge_ratained可使要转换赋值的变量也持有所赋值的对象</p><p>____birdge_transfer被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放</p></blockquote><h3 id="ARC实现"><a href="#ARC实现" class="headerlink" title="ARC实现"></a>ARC实现</h3><p>编译器+oc运行时库 进行内存管理</p><h4 id="strong"><a href="#strong" class="headerlink" title="__strong"></a>__strong</h4><p>通过objc_autoreleaseReturnValue和objc_retainAutoreleaseReturnValue实现了最优化，省略了autoreleasepool注册。</p><h4 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h4><ul><li>若附有__weak修饰符的变量所引用的对象被废弃，则将nil赋值给改变了</li><li>使用附有__weak修饰符的变量，即是使用注册到autoreleasepool中的对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//objc_storeWeak函数将第二参数的赋值对象的地址作为键值，将第一参数附有__weak修饰符的变量地址注册到weak表中，如果第二参数为0，则把变量的地址从weak表中删除。</span><br><span class="line">id obj1;</span><br><span class="line">obj1 = 0;</span><br><span class="line">objc_storeWeak(&amp;obj1,obj);</span><br><span class="line">objc_storeWeak(&amp;obj1,0);</span><br></pre></td></tr></table></figure><p>weak表同引用计数表一样都为散列表</p><p>1.从weak表中获取废弃对象的地址作为键值的记录<br>2.将包含在记录中的所有附有__weak修饰符变量的地址，赋值为nil<br>3.从weak表中删除该记录<br>4.从引用计数表中删除废弃对象的地址为键值的记录</p><blockquote><p>不支持__weak修饰的类，如NSMachPort类</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h1&gt;&lt;h2 id=&quot;引用计数&quot;&gt;&lt;a href=&quot;#引用计数&quot; class=&quot;headerlink&quot; title=&quot;引用计数&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
</feed>
